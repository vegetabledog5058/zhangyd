# JAVA环境以及记事本的编译

## 1.JDK与JVM/JRE的关系

![image-20230731125234855](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311252033.png)

## 2.编写第一个java程序

### 1.记事本写一个java程序(注意大小写敏感)

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311216702.png" style="zoom:33%;" />

### 2.将后缀名txt改为java

### ![image-20230731121801149](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311218299.png)3.该目录下打开cmd运行javac将java文件编译为class文件

区别

.java文件（源文件） 是程序员可以看懂 的文件------通过javac命令—编译

.class文件（字节码文件）是可以被java识别的文件并可以执行文件

### 4.之后发现原目录下出现该class文件

![image-20230731125102150](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311251193.png)

之后发现命令窗口出现程序内容

![image-20230731125142278](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311251326.png)

## 3.环境变量的配置

首先在c盘执行刚才的class文件,失败

![image-20230731125629075](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311256110.png)

将类的查找路径指定到D盘,运行时自动从classpath中查找class类文件,成功(关闭窗口后会失效)

![image-20230731130038762](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311300808.png)

当修改环境变量后,发现可以在任何目录执行class文件

![image-20230731132044858](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311320888.png)

![image-20230731132003366](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311320415.png)

因此:

结论1：在没有配置CLASSPATH环境变量时，java命令在找class文件时是默认在当前目录下寻找的。

结论2：配置过CLASSPATH环境后，java命令是按照CLASSPATH变量中的路径来的寻找class文件的，这就是为什么CLASSPATH变量中配置没有当前目录时，即使当前目录中有class文件，java命令仍然不能正常运行的原因。

三者环境变量的关系为:

![image-20230731132452519](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311324561.png)

## 4.jdk版本的切换以及一些注意事项

通过引用变量方法进行切换(例如切换1.8时,将javahome值改成1.8的变量名),查看时记得重新打开一个命令窗口.

![image-20230731134827634](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311348691.png)

当修改环境变量path时,将安装时自动添加的jdk删除,否则会影响切换,以及需要把这两条保留在最上面,否则添加窗口会变为一行的值;

![image-20230731135121896](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311351946.png)

![image-20230731135509236](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311355364.png)

切换版本成功!

5.在jvm执行JAVA时,会出现中文字符无法输出的情况,是因为电脑编码win10一般默认是GBK而JAVA使用的是UTF-8造成的原因

此时两种解决方案:

1)在Windows系统自带编码修改:依次点击**控制面板 -> 时钟和区域 -> 区域**，弹出**区域**对话框。在**管理**选项卡中找到**非 Unicode 程序的语言**，点击**更改系统区域设置**，勾选**Beta 版：使用 Unicode UTF-8 提供全球语言支持(U)**。!!注此种解决方案不建议使用,会有很多bug

如图

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311835218.png" style="zoom:50%;" />

2)在控制命令符窗口编译成class文件时加入编码 

```cmd
-encoding UTF-8 
```

![image-20230731184218411](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307311842461.png)

## 5.float计算浮点型出现精度缺失的问题

在计算机中，浮点数通常使用有限的二进制位数来近似表示实数。IEEE 754标准规定了浮点数的表示方式，其中float类型使用32位二进制表示，而double类型使用64位二进制表示。这些二进制位数是有限的，无法准确地表示所有的实数。

实数中的某些值（例如 0.1 和 0.2）在二进制表示中是无限循环小数或无限不循环小数。由于浮点数的位数有限，所以在进行浮点数计算时，这些实数值会被近似表示。因此，即使看起来简单的计算，也可能会导致微小的舍入误差。

![image-20230731205440932](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202307312054974.png)

## 6.三种隐式数据类型转换

在Java中，有三种基本数据类型之间的隐式（自动）类型转换：

1. 自动从小类型到大类型的转换：当把一个小类型的数据赋值给一个大类型的变量时，Java会自动进行转换，保证数据不会丢失。这种转换被称为自动类型提升。

   例如：

   ```java
   javaCopy codeint x = 10; // 将int类型的值赋值给一个int类型的变量
   long y = x; // 将int类型的值自动提升为long类型，并赋值给long类型的变量
   ```

2. 自动从浮点类型到更大范围的浮点类型的转换：当把一个小范围的浮点类型的数据赋值给一个更大范围的浮点类型的变量时，Java会自动进行转换。(float-double)

   例如：

   ```java
   javaCopy codefloat a = 3.14f; // 将float类型的值赋值给一个float类型的变量
   double b = a; // 将float类型的值自动提升为double类型，并赋值给double类型的变量
   ```

3. 自动从char类型到整数类型的转换：char类型的数据可以被自动转换为整数类型，因为char类型实际上是一个16位的无符号整数类型。(char-int)

   例如：

   ```java
   javaCopy codechar c = 'A'; // 定义一个char类型的变量c，并赋值为字符'A'
   int intValue = c; // 将char类型的值自动转换为int类型，并赋值给int类型的变量intValu
   ```

## 7.java的三个优点

1. 跨平台性：Java是一种跨平台的编程语言，也称为"Write Once, Run Anywhere"（一次编写，到处运行）。这意味着一次编写的Java代码可以在不同的操作系统上运行，只需在目标平台上安装相应的Java运行时环境（JRE）。这种跨平台性是通过Java虚拟机（JVM）实现的，它在不同平台上提供了一个统一的运行环境，使得Java程序在各种平台上表现一致。
2. 面向对象：Java是一种面向对象的编程语言，支持封装、继承和多态等面向对象的特性。这使得Java代码更加模块化、易于理解和维护。面向对象的设计使得Java可以更好地组织代码，提高代码的重用性，并且支持更复杂的软件开发。
3. 安全性：Java在设计时考虑了安全性，并在语言层面提供了一些安全性特性。例如，Java的虚拟机（JVM）可以对字节码进行安全性检查，防止恶意代码对系统造成破坏。此外，Java提供了安全管理器（Security Manager），允许开发者对程序的访问权限进行控制，确保程序只能访问受限资源。

## 8.高级语言与机器语言的区别

1. 抽象级别：
   - 高级语言：高级语言是相对较为人类友好的编程语言，使用类似于自然语言的表达方式，更加易读、易写和易理解。高级语言的代码更加抽象，使得程序员能够更关注问题的逻辑和算法，而不需要考虑底层的硬件细节。
   - 机器语言：机器语言是计算机硬件能够直接理解和执行的二进制指令。它是计算机最底层的语言，每个指令对应于特定的硬件操作。由于是以0和1的二进制表示，机器语言对人类来说非常晦涩难懂，编写机器语言程序非常繁琐且容易出错。
2. 可读性和可写性：
   - 高级语言：高级语言的代码是人类可读的，使用常见的英语单词和语法规则，更容易理解和编写。高级语言的代码通常比较简洁和易于维护。
   - 机器语言：机器语言的代码是计算机硬件可读的，但对人类来说非常晦涩难懂，不易于直接理解和编写。
3. 可移植性：
   - 高级语言：高级语言具有很强的可移植性，同一份高级语言代码可以在不同的平台上运行，只需将代码编译或解释为目标平台的机器语言即可。
   - 机器语言：机器语言是与特定计算机硬件密切相关的，不同的计算机体系结构需要不同的机器语言代码，缺乏可移植性。
4. 编译与解释：
   - 高级语言：高级语言代码需要通过编译器（或解释器）将其转换为机器语言代码，然后计算机才能执行该代码。
   - 机器语言：机器语言是计算机硬件直接可执行的，不需要额外的编译过程。

## 9.java是一种什么语言?

- 编译语言：编译语言需要通过编译器将整个源代码一次性翻译成目标平台的机器语言，生成独立的可执行文件。

- 解释语言：解释语言不需要生成独立的可执行文件，而是在每次运行时逐行解释执行源代码。

     JAVA

  - 编译阶段：Java 代码首先会被编译成中间代码，称为字节码（Bytecode），这是一种与特定平台无关的中间形式。这个过程由 Java 编译器（javac）完成，生成的字节码文件以 .class 扩展名保存。
  - 解释阶段：Java 字节码并非直接在计算机上执行，而是由 Java 虚拟机（JVM）在运行时逐行解释执行。JVM 是一个运行在不同操作系统上的虚拟计算机，它负责解释字节码并将其转换为底层机器指令，使得 Java 程序能够在不同的平台上运行。

  因此，Java 既经历了编译阶段生成字节码，又在运行时通过解释器（JVM）解释执行字节码，这就使得 Java 既有编译型语言的特点（通过编译生成中间代码），又有解释性语言的特点（在运行时解释执行字节码）。这种执行方式使得 Java 具有跨平台性，一次编写，到处运行。
