# 字符串

## 一.字符串

### 1.字符串的不可变性的本质

> 都知道字符串的值是不可变的,那么本质原因究竟是什么呢?看下面

#### JDk9以前:

> Java 中的 `String` 类的内部实现本质上是一个被 `final` 修饰的字符数组（`char[]`）。这个字符数组存储了字符串的内容，并且 `String` 类提供了一系列的方法来操作和访问这个字符数组，以实现字符串的不可变性。

> 缺点:
>
> 对于大部分字符串来说，其中的字符可能只占用了 Latin-1 字符集的一部分，这就导致了内存的浪费。对于包含大量 ASCII 字符的字符串，每个字符仍然使用 2 个字节来存储，而实际上只需要 1 个字节。

#### JDK9以后:

>Java 9 引入了 `Compact Strings` 优化。这个优化的主要思想是，对于只包含 Latin-1 字符集中的字符的字符串，可以使用 `byte` 类型数组来存储，每个字符只占用 1 个字节，从而减少内存的使用。

> 带来的好处:
>
> 1. **内存节省：** 对于大量包含 Latin-1 字符的字符串，使用 `byte` 类型数组可以将内存使用减少一半，从而降低了内存占用。
> 2. **性能提升：** 由于存储在 `byte` 类型数组中的字符占用更少的内存，可以提高缓存效率，从而可能提高字符串操作的性能。
>
> 需要注意的是，这个优化只适用于只包含 Latin-1 字符的字符串，对于包含其他字符的字符串仍然使用 `char` 类型数组来存储。这样设计的目的是在减少内存占用的同时保持性能。对于开发者来说，这个变化是内部的优化，不会影响到现有的代码，因为 `String` 类的 API 不会发生变化。



### 2.字符串的特性:

> 1. **不可变性：** 字符串是不可变的，这意味着一旦创建了字符串，它的内容就无法更改。当对字符串执行操作（如连接、截取、替换等）时，实际上是创建了一个新的字符串对象，而原始字符串保持不变。这种特性使得字符串操作更加安全和可预测。
> 2. **字符串连接：** 字符串连接是将多个字符串合并成一个字符串的操作。在Java中，可以使用 `+` 运算符来连接字符串。然而，当需要在循环中进行大量的字符串连接操作时，最好使用 `StringBuilder` 或 `StringBuffer` 类来优化性能，因为它们能够避免频繁创建新的字符串对象。
> 3. **字符串比较：** 字符串可以通过使用 `equals` 方法来比较内容是否相等。注意，不能使用 `==` 运算符直接比较字符串，因为它会比较字符串的引用而不是内容。
> 4. **字符串长度：** 可以使用 `length` 方法来获取字符串的长度，即包含的字符数量。注意，数组索引是从 0 开始的，所以最后一个字符的索引是 `length - 1`。
> 5. **空字符串：** 空字符串是长度为零的字符串，表示不包含任何字符。可以使用 `isEmpty()` 方法检查一个字符串是否为空。
> 6. **转义字符：** 字符串中可以包含特殊字符，如换行符 `\n`、制表符 `\t`、回车符 `\r` 等。还可以使用反斜杠 `\` 进行字符转义，例如 `\"` 表示双引号，`\\` 表示反斜杠本身。
> 7. **Unicode 支持：** 字符串可以包含 Unicode 字符，这使得在字符串中使用各种语言的字符和符号变得容易。
> 8. **注意空指针：** 当操作字符串时，务必注意空指针异常。如果一个字符串为 `null`，那么尝试在其上执行方法或操作可能会导致空指针异常。
> 9. **不可变性带来的影响：** 字符串的不可变性使得在进行大量字符串拼接、替换等操作时，可能会导致创建大量的临时对象，影响性能。在性能要求较高的场景中，应该考虑使用 `StringBuilder` 或 `StringBuffer`。

### 3.关于字符串中的串池与编译优化

> 先看一下几道题

```java
                String a = "a";
                String b = "b";

                String c = "ab";
                String d = "a" + "b"; // 编译时优化 ab
                String e = a + "b";
                String f = "a" + b;
                String g = a + b;
                String h = new String("ab"); // 新建一个1个对象,这里地址与串池中不同

// 这里的结果是因为常量"a"和"b"编译时优化,会拼接后赋值给d
  // 而下面带有变量的无法进行编译优化

                System.out.println(c == d); // true    
                 System.out.println(c == e); // false
                System.out.println(c == f); // false
                System.out.println(c == g); // false
                System.out.println(c == h); // false

                System.out.println("-------------------");
                System.out.println(d == e); // false
                System.out.println(e == f); // false
                System.out.println(e == g); // false
                System.out.println(f == g); // false
```

#### 编译优化:

>**常量折叠（Constant Folding）：** 编译器会在编译时计算字符串表达式的值，将字符串拼接操作转换为一个已知的常量字符串，从而避免运行时的计算。
>
>**字符串连接优化：** 如果编译器发现在代码中多次进行字符串连接操作，它可能会将这些连接操作合并为一次操作，从而减少不必要的中间临时字符串的创建和销毁。
>
>**字符串池（String Pool）：** 编译器会自动维护一个字符串池，以减少重复字符串的内存占用。相同的字符串常量在池中只存储一份，多个相同值的字符串引用实际上指向同一个池中的实例。
>
>**编码优化：** 对于使用 ASCII 字符集的字符串，编译器可能会选择使用字节数组来存储，以减少内存使用

### 1.创建字符串的两种方法

```java
	//第一种
String str = "Hello, World!";
//第二种,这种方法在字符串池不存在时会新建两个对象
String str1 = new String();  // 创建一个空字符串
String str2 = new String("Hello");  // 使用字符串字面量初始化
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(charArray);  // 使用字符数组初始化

```

### 2字符串转为数组的方法

#### 1.toCharArray()

>直接在字符串对象上调用。它将字符串转换为一个字符数组，其中字符数组的每个元素对应字符串中的一个字符。这是一个无参数的方法，调用它不需要传递任何参数。

```java
public class Main {
    public static void main(String[] args) {
        String str = "Hello, World!";
        

    char[] charArray = str.toCharArray();
    
    for (char c : charArray) {
        System.out.print(c + " ");
    }
}

}

```

#### 2.通过遍历存到数组

> 翻转遍历为例子
>
> ```java
>  // 翻转遍历顺序
>     String fir = "";
>     for (int i = str.length()-1; i >= 0; i--) {
>         char a = str.charAt(i);
>         fir= fir+a;
>     }
>     return fir;
> }
> ```



## 二.数组转换字符串

#### 1.通过创建对象有参传递

```java
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str3 = new String(charArray);  // 使用字符数组初始化
```

#### 2.通过拼接

```java
char []arr = str.toCharArray();
 String fir = "";
 for (int i = 0,j=arr.length-1; i<j; i++,j--) {
     char tem = arr[i];
     arr[i] = arr[j];
     arr[j] = tem;

 }
 //第二种拼接方法:字符串拼接
 for (int i = 0; i < arr.length; i++) {
     fir+= arr[i];
 }
```

## 三.一些字符串的方法

### 1.charAt()字符串索引

>Java 字符串类（`String`）的一个方法，它用于获取字符串中指定位置的字符

```java
public class Main {
    public static void main(String[] args) {
        String text = "Hello, World!";
        
        char firstChar = text.charAt(0); // 获取第一个字符 'H'
        char fifthChar = text.charAt(4); // 获取第五个字符 'o'
        
        System.out.println("First character: " + firstChar);
        System.out.println("Fifth character: " + fifthChar);
    }
}

```

### 2.subString字符串截取

>方法用于从一个字符串中提取子串
>
>注:因为方法原理是获取一个新字符串,因此需要有变量接收

```java
String substring(int startIndex) // 从 startIndex 开始一直到字符串末尾提取子串。
String substring(int startIndex, int endIndex) //提取子串的起始位置和结束位置。它会提取从 startIndex 到 endIndex - 1
```

```java
public class Main {
    public static void main(String[] args) {
        String text = "Hello, World!";
        

    // 提取从索引 7 开始到末尾的子串
    String sub1 = text.substring(7); 
    System.out.println("Sub1: " + sub1); // 输出：Sub1: World!
    
    // 提取从索引 0 开始到索引 5（不包括）的子串
    String sub2 = text.substring(0, 5);
    System.out.println("Sub2: " + sub2); // 输出：Sub2: Hello
}

}
```

### 3.replace字符串替换

> 于在字符串中替换指定的字符序列

> String replace(要替换的字符串, 新的字符串)
>
> > 注:不识别大小写
>
> ```java
> String str = "你玩的真好,以后TMD,不用玩了tmd真的服了";
>     // 定义敏感词库
>     String []lab = {"sb","tmd","nmd"};
>     //循环遍历数组每一个敏感词进行替换
>     for (int i = 0; i < lab.length; i++) {
>          str = str.replace(lab[i],"***");
>     }
>     System.out.println(str);
> }
> ```
>
> > 运行结果:你玩的真好,以后TMD,不用玩了***真的服了

### 4.**`isEmpty()`**和**`isBlank()`**的区别

> `String` 类提供了两种方法来检查字符串是否为空或空白：

> isEmpty():
>
> 这个方法用于检查字符串是否为空。一个字符串被认为是空的
>
> 只有当且仅当它的长度为 0。
>
> > 换句话说，如果字符串中没有任何字符，那么它就是空的。

```java
String str = "";
boolean isEmpty = str.isEmpty(); // 返回 true
```

> isBlank()
>
> 这个方法用于检查字符串是否为空白。一个字符串被认为是空白的
>
> 当且仅当它不仅长度为 0，或者它里面只包含空格字符、制表符、换行符等不可见的空白字符时

```java
String str = "   \t \n";
boolean isBlank = str.isBlank(); // 返回 true
```

### 5.字符串的比较compareTo

> 字符串之间比较的原理是:
>
> this从第一位开始每一位依次与传递的对象第一位依次比较ASCII码值的大小

```java
public class CompareExample {
    public static void main(String[] args) {
        String str1 = "apple";
        String str2 = "banana";
        String str3 = "apple";

        int result1 = str1.compareTo(str2); // 小于 0
        int result2 = str2.compareTo(str1); // 大于 0
        int result3 = str1.compareTo(str3); // 等于 0

        System.out.println(result1); // 输出: -1
        System.out.println(result2); // 输出: 1     'b' - 'a' = 1
        System.out.println(result3); // 输出: 0
    }
}
```

> 如果返回值小于 0，则表示当前对象小于 `other` 对象。
>
> 如果返回值等于 0，则表示当前对象等于 `other` 对象。
>
> 如果返回值大于 0，则表示当前对象大于 `other` 对象。

### 6.	字符串的连接

> 用于将一个字符串连接到另一个字符串的末尾。
>
> ```java
> String result = str1.concat(" ").concat(str2); 
> // Concatenating two strings with a space in between
> ```

### 7.`indexOf` 和 `lastIndexOf`字符串的查找

>`indexOf` 和 `lastIndexOf` 是 Java 中 `String` 类提供的两个方法，用于查找字符串中某个子字符串的位置
>
>> **`indexOf` 方法：**
>
>- `indexOf` 方法用于查找指定子字符串在主字符串中第一次出现的位置。
>- 它的语法是 `indexOf(String str)`，其中 `str` 是要查找的子字符串。
>- 如果找到了指定子字符串，则返回第一个匹配的字符的索引。如果没有找到，返回 -1。
>
>```java
>String mainString = "Hello, world!";
>int indexOfComma = mainString.indexOf(",");
>System.out.println("Index of comma: " + indexOfComma); // Output: Index of comma: 5
>
>```
>
>> **`lastIndexOf` 方法：**
>
>- `lastIndexOf` 方法用于查找指定子字符串在主字符串中最后一次出现的位置。
>
>- 它的语法是 `lastIndexOf(String str)`，其中 `str` 是你要查找的子字符串。
>
>- 如果找到了指定子字符串，则返回最后一个匹配的字符的索引。如果没有找到，返回 -1。
>
>- ```java
>  String mainString = "Hello, world!";
>  int lastIndexOfL = mainString.lastIndexOf("l");
>  System.out.println("Last index of 'l': " + lastIndexOfL); 
>  // Output: Last index of 'l': 9
>  
>  ```

### 8.split分割字符串

> 用于将一个字符串按照指定的分隔符拆分成多个子字符串，并将这些子字符串存储在数组中
>
> ```java
> public class Main {
>     public static void main(String[] args) {
>         String text = "apple,banana,orange,grape";
> 
>         String[] fruits = text.split(",");
>         
>             System.out.println(Arrays.toString(fruit);
>         
>     }
> }
> 
> ```
>
> 输出:[apple,banana,orange,grape]
>
> 注:分割符会在右边分割,如:
>
> ```java
> String a = "---a-b-c-d--";
>         String arr[] =a.split("-");
>         System.out.println(Arrays.toString(arr));
> 
> ```
>
> 结果:
>
> [, , , a, b, c, d]

### 9.intern

> intern 如果字符串在常量池中有就返回常量池中的对象，
> 如果没有就将对象放入常量池中,并将这个对象返回

>通常情况下，字符串字面量（例如 `"hello"`）在编译时会自动放入字符串池中。因此，直接使用字符串字面量创建的字符串已经在池中了，不需要额外调用 `intern()` 方法。但是，对于运行时生成的字符串，例如通过 `new String("hello")` 创建的字符串，可能不在池中，可以使用 `intern()` 方法将其加入池中，以便实现字符串重用。
>
>```java
>        // 1.
>        String str = "abc";
>
>        String s = new String("abc"); //常量池已经存在"abc",将str地址给s1
>
>        String s1 = s.intern();
>
>        System.out.println(str == s); // false 
>        System.out.println(str == s1); // true 
>        System.out.println(s == s1); // false
>
>//1.`str` 是字符串字面量 `"abc"`，会直接放入字符串池中。`s` 是通过 `new String("abc")` 创建的，会在堆中新创建一个字符串对象，不会放入池中。然后，`s1` 调用 `intern()` 后，会将 `"abc"` 放入池中，因为池中还没有这个字符串。所以，`str == s1` 为 true，但 `str == s` 和 `s == s1` 为 false。
>
>
>        // 2.
>        String s = new String("abc");
>
>        String s1 = s.intern();
>
>        String str = "abc";
>
>        System.out.println(str == s); // false
>        System.out.println(str == s1); // true
>        System.out.println(s == s1); // false
>
>//在这个情况下，s 和 s1 都是通过 new String("abc") 创建的，因此在堆中会有两个相同的字符串对象。然后，s1 调用 intern() 后，会将 "abc" 放入池中，因为池中还没有这个字符串。str在常量池已经存在s1会直接将地址给str,所以，str == s1 为 true，但 str == s 和 s == s1 为 false。
>
>
>        // 3.
>        String  a = "a";
>        String s = new String(a + "bc");
>
>        String s1 = s.intern();
>
>        String str = "abc";
>
>        System.out.println(str == s); //  true
>        System.out.println(str == s1); // true
>        System.out.println(s == s1); //   true
>
>//a 是字符串字面量 "a"，它已经存在于字符串池中。
>//a + "bc" 会在堆中创建一个新的字符串对象 "abc"。
>//s 和 s1 都指向了这个在堆中创建的对象，因为这是通过 new String(...) 创建的对象。
>//s1.intern() 将 "abc" 放入字符串池中，但由于 "abc" 在池中尚不存在，因此会返回这个堆中的对象的引//用。
>//str 是字符串字面量 "abc"，已经存在于字符串池中。
>//因此，str == s、str == s1 和 s == s1 都为 true。
>
>
>         //4.
>        String a = "a";
>        String s = new String(a + "bc");
>
>        String str = "abc";
>
>        String s1 = s.intern();
>
>
>        System.out.println(str == s); //  false
>        System.out.println(str == s1); // true
>        System.out.println(s == s1); //   false
>
>//在这个情况下，a 是字符串字面量 "a"，会放入字符串池中。然后，a + "bc" 创建了一个新的字符串对象 "abc"，放在了堆中。str 是字符串字面量 "abc"，会放入字符串池中。然后，s1 调用 intern() 后，会将 "abc" 放入池中，因为池中还没有这个字符串。所以，str == s1 为 true，但 str == s 和 s == s1 为 false。
>```



10.

## 四:字符串的注意事项

