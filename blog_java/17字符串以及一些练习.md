# 字符串以及一些练习

## 1.字符串的去重

### 1.通过查表进行重复搜索(哈希表)

> 随机生成一个 6 位的密码，要求：
>
> * 不包含重复字符
> * 要有字母和数组
> * 不能以数字开头
>
> 思想:
>
> 1.在数组中寻找元素利用随机数的索引(或利用ASCII码)得到字母和数字
>
> 2.重复的只会是字母,创建数组,长度为26,当某一个字母出现时,例如B出现一次时,在索引1处+1,之后再次随机生成字母时在对应索引的地方检查是否等于0就能判断是否出现过了
>
> 3.
>
> ```java
>  public static String getpassword() {
>         Random r = new Random();
> 
>         int num[] = {};
>         char[] uppercaseArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
>                 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
>                 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
>                 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
>                 'g', 'h', 'i', 'j', 'k', 'l',
>                 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
>         String result = "";
>         int a = r.nextInt(52) + 10;
>         int[] arrb = new int[26];
>         int[] arrs = new int[26];
>         int[] arrnum = new int[10];
>         if (uppercaseArray[a] < 'a') {  //首字母
>             //大写
>             result += uppercaseArray[a];
>             arrs[uppercaseArray[a]-'A']++;
>         } else {
>             result += uppercaseArray[a];
>             arrb[uppercaseArray[a]-'a']++;
>         }
> 
> 
>         while (result.length() < 6) {    ///后五位字母
>             char x = uppercaseArray[r.nextInt(52)];
>             if (x >= 'a') {
>                 //小写
>                 if ((arrb[x - 'a']++) > 1) {
>                     continue;
>                 } else {
>                     arrb[x - 'a']++;
>                     result += x;
>                 }
>             } else if (x > 'A') {
>                 //大写
>                 if ((arrs[x - 'A']++) > 1) {
>                     continue;
>                 } else {
>                     arrs[x - 'A']++;
>                     result += x;
>                 }
>             } else {
>                 if ((arrnum[x - '0']++) > 1) {
>                     continue;
>                 } else {
>                     arrnum[x - '0']++;
>                     result += x;
>                 }
> 
>             }
> 
>         }
>         return result;
>     }
> ```
>
> > 运行结果
> >
> > <img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md1/202308251606928.png" style="zoom:50%;" />

### 2.通过放进一个新的容器进行拼接

> - 可以在StringBuilder容器内进行重复判断(Indexof)
> - 也可以在一个新的字符串进行拼接,区别是stringBuilder容器内可以进行字符串的拼接

> 当容器内不存在时添加字母与数字时候添加元素

### 3.正则表达式

> 可以通过正则表达式匹配搜索目标字符,再通过string方法进行去重

> 1. **Pattern 类：** 用于表示正则表达式的编译表示形式，以及进行正则表达式匹配操作。
>    - `Pattern.compile(String regex)`: 将给定的正则表达式编译为一个 `Pattern` 对象。
>    - `Pattern.matcher(CharSequence input)`: 创建一个 `Matcher` 对象，用于在给定的输入中进行匹配操作。
> 2. **Matcher 类：** 用于执行正则表达式的匹配操作，并提供有关匹配的详细信息。
>    - `Matcher.matches()`: 尝试将整个输入序列与正则表达式进行匹配。
>    - `Matcher.find()`: 尝试在输入序列中查找与正则表达式匹配的子序列。
>    - `Matcher.group()`: 返回上一次匹配操作的结果。
>    - `Matcher.start()` 和 `Matcher.end()`: 返回匹配结果的起始和结束索引。
> 3. **PatternSyntaxException 类：** 用于表示在编译正则表达式时发生的语法错误。

## 2.有效括号

> 给定一个只包括 '('，')' 的字符串，判断字符串是否有效
>
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 注意空字符串可被认为是有效字符串

![image-20230825200122968](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md1/202308252001043.png)

### 思路一:

>通过左右相减(或者计数)的方法进行判断"("数量是否等于右边且计数时")"数量不能大于左边,反之同理
>
>相减:

```java
public static boolean kkk(String str) {
        if(str.indexOf(')')==0||str.lastIndexOf('(')==str.length()-1||str.length()%2!=0){
            return false;
        }
        int numleft = '(';
        int numright = ')';
        int countleft =0;
        int countright =0; 
        for (int i = 1, j = str.length() - 1-1; i < j; i++, j--) {
            //左
            if (str.charAt(i) == '(') {
                //相加
                numleft += +str.charAt(i);
            } else {
                //减
                if(numleft-str.charAt(i)<0){

                    return false;
                }else {
                    numleft -= str.charAt(i);
                    countleft++;

                }
            }
            //右
            if (str.charAt(j) == ')') {
                numright+=str.charAt(j);
            } else {
                //减
                if(numright-str.charAt(j)<0){
                    return false;
                }else {
                    numright -= str.charAt(j);
                    countright++;
                }

            }
        }
        if(((numleft+countleft)/'(')==((numright+countright)/')')){
            return true;
        }else {
            return false;
        }
```

思路二:通过计数遍历,定义一个balance检查是否右括号数量大于左括号,大于时返回false

```java
public static boolean isValidParentheses(String str) {
    if (str.length() % 2 != 0 || str.charAt(0) == ')' || str.charAt(str.length() - 1) == '(') {
        return false;
    }

    int balance = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (c == '(') {
            balance++;
        } else if (c == ')') {
            balance--;
        }
        if (balance < 0) {
            return false;
        }
    }

    return balance == 0;
}

public static void main(String[] args) {
    String test1 = "()()((()))";
    String test2 = "((())())";
    String test3 = "()(()))";
    
    System.out.println(isValidParentheses(test1)); // true
    System.out.println(isValidParentheses(test2)); // true
    System.out.println(isValidParentheses(test3)); // false
}

```

## 3.最长子串

>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

![image-20230825201740721](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md1/202308252017777.png)

### 方法一

1.检查不出现重复的每一个子串记录最长子串,依次进行比较,每一次对比子串与目标

```java
public static String subString1(String str) {
         String max = ""; // 存储最长子串(默认为"")
        int start = 0; // 子串的起始下标
        for (int end = start + 1; end < str.length(); end++) {
            // 子串的范围
            String sub = str.substring(start, end);
            // 当前位置的字符
            String current = str.substring(end, end + 1);
            // 当前位置的字符是否在子串中存在;存在时停止进行判断储存
            if (sub.indexOf(current) != -1) {
                // 当前子串和目前最大子串谁大
                if (sub.length() > max.length()) {
                    max = sub;
                }

                // 找下一个子串的开始坐标,下一个子串的坐标应是从上一个子串结束位置+1或者end处开始
//                str.indexOf(current);  sub.indexOf()
                start = str.indexOf(current, start) + 1;

                // 最长子串比剩下的长度还长 
                if (max.length() > str.length() - start - 1) {
                    break;
                }
            } else if (end == str.length() - 1) { // 不存在并且是最后一个
                sub = str.substring(start); // 一直到最后一个都没有重复的
                // 当前子串和目前最大子串谁大
                if (sub.length() > max.length()) {
                    max = sub;
                }
            }

        }
        return max;
    }
```

### 方法二

> 暴力破解
>
> ```java
>  public static String baolipojie(String str) {
>         String max = "";
>         for (int start = 0; start < str.length(); start++) {
>             String sub = str.substring(start, start + 1);
>             for (int end = start + 1; end < str.length(); end++) {
>                 String current = str.substring(end, end + 1);
> 
>                 if (sub.contains(current)) {
>                     if (sub.length() > max.length()) {
>                         max = sub;
>                     }
>                     break;
>                 } else {
>                     sub += current;
>                 }
>             }
>         }
>         return max;
>     }
> ```
>
> 

## 4.最长公共前缀

> 编写一个函数来查找字符串数组中的最长公共前缀。
> 如果不存在公共前缀，返回空字符串 "" 
>
> 输入：strs = ["flower","flow","flight"]
> 输出："fl"

### 方法一

1.选取索引0不断减少

> ```java
> public static String Long(String[] strs) {
> 
>         int index = 1;
>         int i = 0;
>         StringBuilder sb = new StringBuilder(strs[0]);
>         while (index < strs.length) {
>             int length = Math.min(sb.length(), strs[index].length());  // 获取较小的长度
> 
>             if (sb.toString().equals(strs[index].substring(0, length))) {
>                 //true
>                 index++;
>                 continue;
>             } else {
>                 //false
>                 if (i != strs[0].length() - 1) {
>                     sb.deleteCharAt(strs[0].length() - 1 - i);
>                     i++;
>                     continue;
>                 } else {
>                     return "";
>                 }
>             }
> 
> 
>         }
>         return sb.toString();
>     }
> ```
>
> 

### 方法二

2.选取最短长度不断增加长度进行比较

```java
 private static String maxPublicPreLength(String[] arr) {
        // 最短元素长度
//        int minIndex = 0;
//        for (int i = 1; i < arr.length; i++) {
//            if (arr[i].length() < arr[minIndex].length()) {
//                minIndex = i;
//            }
//        }

        // 假设这个最短元素就是最长公共前缀
        String min = arr[0];

        // 有几位就循环几次
        count:
        for (int i = 0, j = 1; i < arr[0].length(); i++) {
            // 循环遍历，每一个元素是不是都是以这个元素开头的
            for ( ; j < arr.length; j++) {
                if (!arr[j].startsWith(min)) {
                    // 如果不是，减一个字符
                    min = min.substring(0, min.length() - 1);
                    continue count;
                }
            }
            break;
        }

        return min;
    }
```

