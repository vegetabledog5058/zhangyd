

## 冒泡排序

### 介绍:

在冒泡排序中，只有当两个元素不满足条件的时候才会需要交换，所以只有后一个元素大于前一个元素时才进行交换，这时的冒泡排序是一个稳定的排序算法。

### 步骤：

比较相邻的元素。如果第一个比第二个大，就交换他们两个。

对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

针对所有的元素重复以上的步骤，除了最后一个。

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

> 本质上是一个数组经过每轮将最大/第二大/第三大(以此类推)逐个将数放在最后/次后的算法

![img](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081509768.gif)

![](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081116077.png)

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081120442.png" style="zoom:40%;" />

> 这里将{5,1,2,4,9,3}通过第一次排序后,将最大的9通过换位放在最后,同时一个数在n个数中比较大小,不需要和自身进行比较,因此只需要n-1次,在数组中也就是array.length-1次

 在内部循环中,也就是第二轮循环寻找第二大数值时,最大的数与第二大的数字在第一轮已经进行过比较,所以可以省略比较步骤

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081127730.png" style="zoom:50%;" />

> 当i=2时,也就是外层循环进行第三轮比较时,(第三大的数字),第三大数字与第二大(5和4)在上一轮已经进行过比较,因此省略多余步骤,(5和9依然不需要再次比较)

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081129426.png" style="zoom:50%;" />

以此类推,可以发现重复的步骤与i的值相同,因此我们可以得出内部循环的结束条件为:array.length-1-i

### 程序中执行:

```java
public static void main(String[] args) {
    int []array = {5,1,2,4,9,3};
    for (int i = 0; i < array.length-1; i++) {
        for (int j = 0; j < array.length-1-i; j++) {
            if(array[j]>array[j+1]){
                int tem = array[j];
                array[j] = array[j+1];
                array[j+1] = tem;
            }
        }
    }
    System.out.println(Arrays.toString(array));
}
```

![image-20230808114235876](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081142425.png)

## 选择排序

### 步骤：

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。

再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

重复第二步，直到所有元素均排序完毕。

> 简单来说就是找到最小数字的索引，与第一个数字交换，然后从第二个开始找到最小的数（此时最小的数是第二小的数，因为最大的已经排到了它的前面）

![img](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081509704.gif)

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081518562.png" style="zoom:50%;" />

> 在外循环中，执行的次数是array.lenth-1，因为从数组第二位开始与自身进行比较
>
> 内循环开始执行,依次与3以后的数字进行比较,直到有比3还小的数时,记录索引min
>
> 否则继续遍后面的数

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081522212.png" style="zoom:50%;" />

> 当i=1时,进行第二位数字的寻找,与第一遍不同的是.此时无需再比较数组i=0,(也就是当前索引以前的数字,因为前面的数字当前已经是最小的数).也就是j只需要从i+1开始执行
>
> <img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081528924.png" style="zoom:50%;" />

最终

### 程序中执行

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081640811.png" alt="image-20230808164046300" style="zoom:67%;" />

## 插入排序

### 步骤:

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

> 简单说就是从数组第二个开始默认前面已经拍好序列,记录这一位数组的值,当该数大于前面数时插入,小于前面数时,将前面放索引+1也就是后移,直到该数大于前一位时插入,依次往后

![img](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081643322.gif)

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081648037.png" alt="image-20230808164852907" style="zoom:50%;" />

> 当i=1的时候,记录前一位的索引为preIndex,可以发现5大于3,此时直接插入,默认前面已经排好序(前面是3),

![image-20230808165001901](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081650932.png)

>i=2的时候,此时preIndex的值右移变为1,然后此时需要丛2开始进行插入,当2与5比较时候,小于5,因此5的索引此时后移(不必担心会改变数组原有的值,此时后移,占用的是原来为2索引为2的位置)
>
>之后原来为5的数组的值变成2,preIndex--;(每当数组的值后移的时候-1),此时再次与preIndex的值比较,依然小于前一个数,于是再次preIndex--;并且将3的索引后移;但是此时preIndex为-1,说明以及到达数组边界,因此将2放到该位置变成{2,3,5,8,9,6}

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081657825.png" alt="image-20230808165724775" style="zoom:50%;" />

> i=3,i=4的时候,分别插入8,9;发现都大于preIndex所对应数,因此直接插入

<img src="https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081705562.png" alt="image-20230808170554514" style="zoom:50%;" />

> i=5时,6小于9;因此将6向前继续比较,9和8依次后移,preIndex分别为4,3;最终得到排序结果

![image-20230808171053918](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081710965.png)

### 程序中执行

![image-20230808174253614](https://cdn.jsdelivr.net/gh/vegetabledog5058/photo/md/202308081742978.png)

