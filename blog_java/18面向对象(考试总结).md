# 面向对象

## 一.this和super的区别

### 1.this表示当前对象，super指代父类对象。

### 2.this可以解决变量遮蔽问题，super可以解决隐藏问题。

> ```java
> class Parent {
>     int x = 10;
> }
> 
> class Child extends Parent {
>     int x = 20;
>     
>     void displayX() {
>         System.out.println("Child's x: " + x); // 子类自己的x
>         System.out.println("Parent's x: " + this.x); // 使用this引用子类的x
>         System.out.println("Parent's x: " + super.x); // 使用super引用父类的x
>     }
> }
> 
> public class Example {
>     public static void main(String[] args) {
>         Child child = new Child();
>         child.displayX();
>     }
> }
> 
> ```

### 3.this调用属性或方法时，本类没有可以调用父类的；super调用父类的属性或方法。

### 4.this可以在任何类中使用，super出现在子类中。

### 5.都只能在实例方法、构造方法或实例初始化器中使用。(也就是说都无法在类方法中使用)

### 6.都可以表示构造方法的调用，并且只能在构造方法第一行，不能同时出现。如果子类构造中调用父类无参构造

方法时，此时 super() 可以省略。

> 注:子类没有显示调用父类无参构造时,默认调用父类的无参构造

> ```java
> class Parent {
>     Parent(int value) {
>         System.out.println("Parent's parameterized constructor: " + value);
>     }
> }
> 
> class Child extends Parent {
>     Child() {
>         super(10); // 调用父类的有参构造方法
>         System.out.println("Child's no-arg constructor");
>     }
>     
>     Child(int value) {
>         this(); // 调用同一类中的无参构造方法
>         System.out.println("Child's parameterized constructor: " + value);
>     }
> }
> 
> public class Example {
>     public static void main(String[] args) {
>         Child child1 = new Child(); // 调用子类的无参构造方法
>         Child child2 = new Child(20); // 调用子类的有参构造方法
>     }
> }
> 
> ```

> 输出

```java
Parent's parameterized constructor: 10
Child's no-arg constructor
Child's parameterized constructor: 20

```



## 二.子类的实例化过程

1. **加载父类和子类的类定义**：在实例化子类之前，需要加载父类和子类的类定义。这可以通过类加载器来实现，确保在实例化子类之前，父类的信息已经加载到内存中。

2. **分配内存空间**：和单独的类实例化类似，需要为子类对象分配足够的内存空间来存储其属性和方法。这个内存分配步骤包括子类和父类的成员。

3. **调用父类的构造方法**：在子类的构造方法中，通常会调用父类的构造方法来初始化从父类继承的属性。这可以通过使用`super()`关键字调用父类构造方法来实现。

4. **初始化父类属性**：子类的构造方法在调用父类构造方法后，可以初始化从父类继承的属性。

5. **执行子类的构造方法**：子类的构造方法会在父类构造方法执行后继续执行，用于初始化子类特有的属性和执行其他需要的操作。

6. **设置属性的初始值**：构造方法可以设置属性的初始值，包括从父类继承的属性和子类自己的属性。

7. **执行实例初始化器（可选）**：子类中定义的实例初始化器会在子类构造方法之前执行，用于执行一些子类特定的操作。

8. **返回子类对象引用**：构造方法在初始化完成后，会返回一个指向新创建的子类对象的引用。

9. **使用子类对象**：一旦子类对象被创建并初始化，就可以使用它来调用继承自父类的方法、访问和修改从父类继承的属性，以及调用子类自己的方法。

   ```java
   class Animal { //1加载父类和子类的类定义
       String species;
       
       public Animal(String species) {
           this.species = species;
           System.out.println("Animal constructor executed.");
       }
       
       public void speak() {
           System.out.println("Animal speaks.");
       }
   }
   
   class Dog extends Animal {
       String name;
       
       public Dog(String name) {
           //子类的构造方法中，通常会调用父类的构造方法来初始化从父类继承的属性。这可以通过使用`super()`关键字调用父类构造方法来实现。
           super("Dog");
           this.name = name;
           System.out.println("Dog constructor executed.");
       }
       
       @Override
       public void speak() {
           System.out.println("Dog barks.");
       }
       
       public void fetch() {
           System.out.println("Dog fetches.");
       }
   }
   
   public class Main {
       public static void main(String[] args) {
           Dog myDog = new Dog("Buddy"); // 实例化子类
           myDog.speak(); // 调用子类方法
           myDog.fetch(); // 调用子类特有方法
       }
   }
   
   ```

   

## 三.面向对象三大特征

1.封装：通过访问修饰符控制成员变量和成员方法的访问权限，并对外提供访问方式（合理暴露合理隐藏）。
2.继承：子类对父类的扩展，子类可以继承父类的属性和方法，从而实现代码的复用；并且可以添加自己的属性
和方法或重写父类的方法，从而实现对父类的扩展。继承是一种 is a 的关系， final 修饰的类不能被继承；
Object 是所有类的父类；在 Java 中，类只能单继承。
3.多态：类或方法的多种形态。父类引用指向子类对象，调用方法的时候要看具体的是哪一个对象，方法重写是
实现运行时多态的基础；方法重载是编译时多态；多态允许针对不同对象调用统一的接口，实现了代码的重用
性和可扩展性。

## 四.java中的访问修饰符

Java中访问修饰符有三个 public 、 protected 、 private ，四种访问权限，分别是：

- public 表示可以在本项目中任意地方访问。

- protected 表示可以在同包任意类或不同包子类中访问。

- package-access (缺省)表示可以在同包中访问。

- private 表示只能在当前类中访问。

  其中，类的访问权限有 public 和 package-access （缺省），类成员的访问权限有 public 、 protected 、
  private 和 package-access （缺省）。

## 五.重载和重写的区别

1.在同一类中，存在方法名相同，参数列表不同（个数、类型或顺序不同）的方法互为重载。
2.在继承关系中，子类声明一个继承自父类的方法名相同、参数列表相同，返回值类型一致，访问修饰符相同或
变大，抛出异常相同或缩小的方法称为重写。
3.重载是编译时多态，重写是运行时多态

1. **重载（Overloading） - 编译时多态：** 重载发生在同一个类中，当一个类中有多个方法具有相同的名称但具有不同的参数列表时。编译器根据方法的参数类型和数量来确定调用哪个方法。在编译时，编译器能够根据调用时提供的参数信息准确地选择要调用的方法。因为这种多态性在编译时就可以确定，所以称之为编译时多态。
2. **重写（Overriding） - 运行时多态：** 重写发生在父类和子类之间，当子类重新定义了父类中的方法（方法名、参数列表和返回类型都相同）时，子类对象调用该方法时会调用子类中的方法而不是父类中的方法。在运行时，Java虚拟机（JVM）根据对象的实际类型来决定要调用的方法。因为这种多态性需要在运行时确定对象的类型并执行相应的方法，所以称之为运行时多态。

## 六.类中可以声明哪些内容，哪些可以被继承，哪些不能被继承。

1.类中可以声明静态初始化器 、实例初始化器 、构造方法、成员变量 、成员方法 、成员类、成员接口等。
2.

- 同包下，可以被继承的有非 private 的成员(变量、方法、成员类、成员接口等)，

- 不同包，可以被继承的有
  public 及 protected 修饰的成员（变量、方法、成员类、成员接口等）。
  3.一定不能被继承的有静态初始化器、实例初始化器、

  构造方法、(如果子类没有明确地调用父类的构造方法，Java 编译器会默认在子类构造方法中插入对父类无参数构造方法（如果父类有无参数构造方法）的调用

  或者可以使用 `super(...)` 调用特定的父类构造方法。)私有属性、私有方法、私有成员类、私有成员
  接口等。

## 七.类方法的一些概念

1.类方法中不能用this调用,this调用的是实例方法

2,类方法可以调用其他类的方法

3.类方法中可以调用实例方法,可以先实例化对象,但是不推荐,一般是通过类名调用

## 八.运行错误和编译错误的区别

**编译错误（Compile-time Error）：** 这类错误在编写代码时会被编译器检测到并报告。编译错误通常是语法错误、类型错误、命名错误等。这些错误会阻止代码成功编译成可执行的程序。如果代码存在编译错误，通常无法生成有效的可执行文件，因此程序无法运行。

```java
public class Example {
    public static void main(String[] args) {
       Message(); // 编译错误
    }
    
    public static void displayMessage() {
        System.out.println("Hello, world!");
    }
}

```

**运行时错误（Runtime Error）：** 这类错误在程序执行过程中发生，可能导致程序异常终止或产生不正确的结果。运行时错误也称为异常（Exception）。这些错误通常与输入数据、资源不足、除零错误、空指针引用等问题相关。虽然这些错误在编译时不会被检测到，但可以通过异常处理机制来捕获和处理。

```java
public class Example {
    public static void main(String[] args) {
        int result = divide(10, 0); // 运行时错误：除以零
        System.out.println("Result: " + result);
    }
    
    public static int divide(int a, int b) {
        return a / b;
    }
}

```

